const fs = require('fs');
const os = require('os');
const path = require('path');
const { spawn } = require('child_process');

let state = {
  running: false,
  pid: null,
  startedAt: null,
  lastError: '',
  lastLogLines: [],
  tunnelName: '',
  tunnelId: '',
  tunnelTokenSet: false,
  configPath: '',
  credFile: '',
};

let child = null;

function pushLog(line) {
  const text = String(line || '').trim();
  if (!text) return;
  state.lastLogLines.push(text);
  if (state.lastLogLines.length > 200) state.lastLogLines.splice(0, state.lastLogLines.length - 200);
}

function findCloudflaredBinary() {
  const exeName = process.platform === 'win32' ? 'cloudflared.exe' : 'cloudflared';
  const candidates = [];

  if (process.resourcesPath) {
    candidates.push(path.join(process.resourcesPath, 'app.asar.unpacked', 'node_modules', 'cloudflared', 'bin', exeName));
  }

  candidates.push(path.join(__dirname, '..', '..', '..', 'node_modules', 'cloudflared', 'bin', exeName));
  candidates.push(path.join(process.cwd(), 'node_modules', 'cloudflared', 'bin', exeName));

  for (const p of candidates) {
    try {
      if (p && fs.existsSync(p)) return p;
    } catch {
      // ignore
    }
  }

  return 'cloudflared';
}

function getDefaultCloudflaredDir() {
  if (process.platform === 'win32') {
    const base = process.env.USERPROFILE || os.homedir();
    return path.join(base, '.cloudflared');
  }
  return path.join(os.homedir(), '.cloudflared');
}

function pickCredFile(cloudflaredDir, preferredTunnelId = '') {
  try {
    if (!cloudflaredDir || !fs.existsSync(cloudflaredDir)) return '';

    const preferred = String(preferredTunnelId || '').trim();
    if (preferred) {
      const p = path.join(cloudflaredDir, `${preferred}.json`);
      if (fs.existsSync(p)) return p;
    }

    const entries = fs.readdirSync(cloudflaredDir);
    const jsons = (entries || [])
      .filter((n) => String(n).toLowerCase().endsWith('.json'))
      .map((n) => path.join(cloudflaredDir, n));

    // Prefer a UUID-like filename if present.
    const uuidLike = jsons.find((p) => /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\.json$/i.test(p));
    return uuidLike || jsons[0] || '';
  } catch {
    return '';
  }
}

function buildConfigYml({ configPath, credFile, defaultServiceUrl, baseDomain }) {
  const tunnelId = String(path.basename(credFile || '')).replace(/\.json$/i, '');
  const safeCred = String(credFile || '').replace(/'/g, "''");
  const safeDomain = String(baseDomain || '').replace(/'/g, "''");
  const safeService = String(defaultServiceUrl || '').replace(/'/g, "''");

  // YAML notes:
  // - wildcard hostnames MUST be quoted (otherwise `*` is treated as an alias)
  // - on Windows, backslashes inside double quotes can be parsed as escape sequences (e.g. \Uxxxx), so use single quotes for paths.
  const content = `# Auto-generated by Turbonox\n# Named tunnel configuration\n\n# The tunnel id matches the credentials filename\ntunnel: ${tunnelId}\ncredentials-file: '${safeCred}'\n\ningress:\n  - hostname: '${safeDomain}'\n    service: '${safeService}'\n  - hostname: '*.${safeDomain}'\n    service: '${safeService}'\n  - service: http_status:404\n`;

  fs.mkdirSync(path.dirname(configPath), { recursive: true });
  fs.writeFileSync(configPath, content, 'utf8');
  return content;
}

function buildConfigYmlWithToken({ configPath, defaultServiceUrl, baseDomain }) {
  const safeDomain = String(baseDomain || '').replace(/'/g, "''");
  const safeService = String(defaultServiceUrl || '').replace(/'/g, "''");

  // Token-based connectors do not require a local credentials-file in the config.
  // YAML notes:
  // - wildcard hostnames MUST be quoted (otherwise `*` is treated as an alias)
  const content = `# Auto-generated by Turbonox\n# Named tunnel configuration (token-based connector)\n\ningress:\n  - hostname: '${safeDomain}'\n    service: '${safeService}'\n  - hostname: '*.${safeDomain}'\n    service: '${safeService}'\n  - service: http_status:404\n`;

  fs.mkdirSync(path.dirname(configPath), { recursive: true });
  fs.writeFileSync(configPath, content, 'utf8');
  return content;
}

function start({
  tunnelName,
  credFile,
  preferredTunnelId,
  tunnelToken,
  configDir,
  baseDomain,
  defaultServiceUrl,
}) {
  if (child && state.running) return state;

  const name = String(tunnelName || '').trim() || 'turbonox';
  const bd = String(baseDomain || '').trim() || 'turbonox.oriko.lk';
  const svc = String(defaultServiceUrl || '').trim() || `http://localhost:${process.env.VOID_BACKEND_PORT || 3456}`;

  const cDir = String(configDir || '').trim() || path.join(getDefaultCloudflaredDir(), 'turbonox-managed');
  const cfgPath = path.join(cDir, 'config.yml');

  const token = String(tunnelToken || '').trim();
  const useToken = Boolean(token);

  const cfDir = getDefaultCloudflaredDir();
  const prefId = String(preferredTunnelId || '').trim();

  let cred = '';
  let tunnelId = '';

  if (!useToken) {
    cred = String(credFile || '').trim() || pickCredFile(cfDir, prefId);
    if (!cred || !fs.existsSync(cred)) {
      state = {
        ...state,
        running: false,
        pid: null,
        startedAt: null,
        lastError: prefId
          ? `Missing Cloudflare tunnel credentials for tunnel ID ${prefId}. Expected ${path.join(cfDir, `${prefId}.json`)}`
          : `Missing Cloudflare tunnel credentials. Expected a *.json in ${cfDir} (or set dns_tunnel_token)`,
        tunnelName: name,
        tunnelId: '',
        tunnelTokenSet: false,
        configPath: cfgPath,
        credFile: cred,
      };
      return state;
    }
    tunnelId = String(path.basename(cred)).replace(/\.json$/i, '');
  } else {
    // In token mode, there may be no local <tunnelId>.json, but we can still surface the pinned ID.
    // (Cloudflared logs also include the tunnelID, but parsing logs is brittle.)
    if (prefId) tunnelId = prefId;
  }

  try {
    if (useToken) {
      buildConfigYmlWithToken({ configPath: cfgPath, defaultServiceUrl: svc, baseDomain: bd });
    } else {
      buildConfigYml({ configPath: cfgPath, credFile: cred, defaultServiceUrl: svc, baseDomain: bd });
    }
  } catch (e) {
    state = {
      ...state,
      running: false,
      pid: null,
      startedAt: null,
      lastError: e?.message || 'Failed to write cloudflared config',
      tunnelName: name,
      tunnelId: tunnelId || '',
      tunnelTokenSet: useToken,
      configPath: cfgPath,
      credFile: cred,
    };
    return state;
  }

  const bin = findCloudflaredBinary();

  state.lastError = '';
  state.lastLogLines = [];
  pushLog(`[CLOUDFLARED] Starting tunnel: ${name}${tunnelId ? ` (${tunnelId})` : ''}`);
  pushLog(`[CLOUDFLARED] Using config: ${cfgPath}`);
  if (useToken) {
    pushLog('[CLOUDFLARED] Using connector token');
  } else {
    pushLog(`[CLOUDFLARED] Using creds: ${cred}`);
  }

  // Prefer token flow if provided; otherwise run by tunnel UUID to avoid name collisions.
  const args = useToken
    ? ['tunnel', '--config', cfgPath, 'run', '--token', token]
    : ['tunnel', '--config', cfgPath, 'run', tunnelId];

  child = spawn(bin, args, {
    windowsHide: true,
  });

  state.running = true;
  state.pid = child.pid || null;
  state.startedAt = new Date().toISOString();
  state.tunnelName = name;
  state.tunnelId = tunnelId || '';
  state.tunnelTokenSet = useToken;
  state.configPath = cfgPath;
  state.credFile = cred;

  child.stdout?.on('data', (d) => pushLog(d.toString()));
  child.stderr?.on('data', (d) => pushLog(d.toString()));

  child.on('error', (e) => {
    state.lastError = e?.message || 'cloudflared process error';
    state.running = false;
    state.pid = null;
    state.startedAt = null;
    child = null;
  });

  child.on('close', (code) => {
    pushLog(`[CLOUDFLARED] exited with code ${code}`);
    state.running = false;
    state.pid = null;
    state.startedAt = null;
    child = null;
  });

  return state;
}

function stop() {
  if (!child) {
    state.running = false;
    state.pid = null;
    state.startedAt = null;
    return state;
  }

  try {
    child.kill('SIGTERM');
  } catch {
    // ignore
  }

  child = null;
  state.running = false;
  state.pid = null;
  state.startedAt = null;
  return state;
}

function status() {
  return {
    ok: true,
    cloudflared: {
      running: Boolean(state.running),
      pid: state.pid,
      startedAt: state.startedAt,
      tunnelName: state.tunnelName,
      tunnelId: state.tunnelId,
      configPath: state.configPath,
      credFile: state.credFile,
      lastError: state.lastError,
      lastLogLines: state.lastLogLines,
    },
  };
}

module.exports = {
  start,
  stop,
  status,
};
